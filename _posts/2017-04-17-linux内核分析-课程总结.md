---

layout: post

title: 'linux内核分析-课程总结'

date: '2017-04-17'

header-img: "img/home-bg.jpg"

tags:
     - linux
author: 'De4dCr0w'

---

<!-- more -->

>版权声明：本文为博主原创文章，未经博主允许不得转载。
>
>罗军 + 原创作品转载请注明出处 + 《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000  

### 第一周 ###

[计算机是如何工作的？](https://de4dcr0w.github.io/2017/02/16/%E5%88%86%E6%9E%90%E7%AE%80%E5%8D%95C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F/)

通过汇编一个简单的C程序，了解了如何反汇编一个程序，通过分析汇编程序，我们可以学习到了函数传递参数的方式和程序执行过程中栈空间的变化。了解了各个寄存器的作用，这节课是整门课程的基础。

### 第二周 ###

[操作系统是如何工作的？](https://de4dcr0w.github.io/2017/02/28/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F/)

这节课我们学到了栈帧的含义，Volatile的意义，更重要的是我们通过实验代码直观地了解了进程切换的具体过程，这节课我们历时了两周，经过课堂讨论，课上改代码，最后总结，不断纠正自己一开始的理解，最后清晰并正确地了解进程切换的过程。重点难点：栈空间的切换。

### 第三周 ###

[构造一个简单的Linux系统MenuOS](https://de4dcr0w.github.io/2017/03/12/linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/)

这节课我们从零开始学习构建了MenuOS系统，并用gdb调试linux内核的启动过程，在start_kernel上下断点，跟踪调试，可以看到中断门，陷阱门的初始化函数trap_init、内存初始化函数mem_init、系统调度初始化函数sched_init。重点难点：0号进程的初始化和1号进程开始的地方。

### 第四周 ###

[扒开系统调用的三层皮（上）](https://de4dcr0w.github.io/2017/03/19/%E5%88%86%E6%9E%90fork%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/)

这节课我们通过fork函数来学习系统调用的流程，主要是了解系统调用的三层皮：API，中断向量，中断服务程序（对应xyz、system_call和sys_xyz），还需要了解的知识点是：system_call是Linux中所有系统调用的入口点，每个系统调用至少有一个参数，即由eax传递的系统调用号。要了解API和函数调用的关系，还有中断是怎么产生和怎么和系统调用联系起来的。


### 第五周 ###

[扒开系统调用的三层皮(下)](https://de4dcr0w.github.io/2017/03/20/system_call%E5%88%B0iret%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/)

这篇博客开篇介绍了中断的分类和中断的处理过程，这是比较重要的一点，我们需要了解在linux内核启动过程中，start_kernel中trap_init()函数初始化了中断门，通过set_system_intr_gate->set_gate进行设置，通过write_idt_entry将中断信息写进中断描述符表IDT。然后主要介绍system_call到iret之间发生了什么，画了比较详细的流程图。

### 第六周 ###

[进程的描述和进程的创建](https://de4dcr0w.github.io/2017/03/31/%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E5%92%8C%E5%88%9B%E5%BB%BA/)

这节课主要是介绍进程的结构，以及如何创建一个新进程。在基础知识方面我们需要了解写时复制技术。实际上创建进程实际是通过系统调用那节课我们用来举例的fork函数，所以我在博客里主要分析了fork函数做了哪些操作以及整个流程，涉及到的主要函数有：do_fork、copy_process、copy_thread、wake_up_new_task，并介绍每个函数具体的操作。

### 第七周 ###

[可执行程序的装载](https://de4dcr0w.github.io/2017/04/09/Linux%E5%86%85%E6%A0%B8%E5%A6%82%E4%BD%95%E8%A3%85%E8%BD%BD%E5%92%8C%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/)

这节课我们主要学习如何Linux内核如何装载和启动一个可执行程序。我们首先了解了动态编译和静态编译的区别，学习了ELF文件格式、GOT表、plt表，通过gdb和ida反汇编了解了动态链接的过程，然后分析如何启动一个静态编译的程序。主要是分析execve系统调用的执行流程，关键函数有load_elf_binary、start_thread。

### 第八周 ###

[进程的切换和系统的一般执行过程](https://de4dcr0w.github.io/2017/04/15/%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/)

这节课我们主要学习进程调度的时机、进程切换的一般过程、进程上下文信息  

* 用户地址空间：包括程序代码，数据，用户堆栈等
* 控制信息：进程描述符，内核堆栈等
* 硬件上下文（注意中断也要保存硬件上下文只是保存的方法不同）

然后分析了进程切换的源码结构，流程为：schedule()->__schedule()->context_switch->switch_to->jmp __switch_to


### 课程总结 ###

学习linux内核真的是获益良多，对于linux内核的学习不能事事巨细，要先有整体的框架和概念，但是一旦涉及到某一点，那就可以抛开次要的函数，对这一点进行深究，这样才会理解深入。Linux内核包罗万象，当实际工程中遇到相关的知识点就可以返回去通过linux内核了解，任何人都可以从这里获取营养，总之学习Linux内核为我开启了一扇神奇的大门。